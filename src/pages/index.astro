---
import Layout from '../layouts/Layout.astro';
---

<Layout title="AniGen - Anime Image Viewer">
  <div class="container" id="container">
    <header class="header">
      <h1 class="title text-gradient">Anime Image API Crawler</h1>
      <div class="source-selector">
        <button class="source-button" id="sourceButton">
          <span id="currentSource">waifuPics</span> ‚ñº
        </button>
        <div class="source-dropdown" id="sourceDropdown">
          <!-- Sources will be populated by JavaScript -->
        </div>
      </div>
    </header>

    <main class="main-content" id="mainContent">
      <div class="image-container" id="imageContainer">
        <img 
          class="main-image" 
          id="mainImage" 
          alt="Anime image"
          style="display: none;"
        />
        <div class="loading-spinner" id="loadingSpinner"></div>
        <div class="error-message" id="errorMessage" style="display: none;">
          Failed to load image. Please try again.
        </div>
        <div class="swipe-hint" id="swipeHint">
          Swipe or use A/D keys to navigate
        </div>
      </div>
    </main>

    <div class="controls">
      <button class="control-button primary" id="rewindButton" title="Previous image (A key)" disabled>
        ‚è™
      </button>
      <button class="control-button primary" id="refreshButton" title="Next image (D key)">
        ‚è©
      </button>
      <button class="control-button primary" id="heartButton" title="Download image (F key)">
        ‚ù§Ô∏è
      </button>
      <button class="control-button primary" id="safariButton" title="Open in new tab" disabled>
        üîó
      </button>
    </div>

    <div class="keyboard-hint" id="keyboardHint">
      A: Previous | D: Next/New | W: Fullscreen | S: Exit Fullscreen | F: Download
    </div>

    <footer class="footer-text">
      <p>made with <a href="https://github.com/withastro/astro" target="_blank" class="text-gradient">Astro</a> and much ‚ù§Ô∏è by mlemors</p>
    </footer>

    <!-- Dropdown backdrop -->
    <div class="dropdown-backdrop" id="dropdownBackdrop"></div>
  </div>
</Layout>

<script>
  import { ImageSource, ImageApiService, type ImageData } from '../services/imageApis';

  interface ImageHistoryItem extends ImageData {
    timestamp: number;
  }

  class AnimeImageViewer {
    private currentSource: ImageSource = ImageSource.WAIFU_PICS;
    private imageHistory: ImageHistoryItem[] = [];
    private currentImageIndex: number = -1;
    private isLoading: boolean = false;
    private touchStartX: number = 0;
    private touchEndX: number = 0;
    private isFullscreen: boolean = false;
    
    // Preloading system
    private preloadedImages: Map<string, ImageData> = new Map();
    private maxPreloadedImages: number = 3;
    private isPreloading: boolean = false;
    private preloadAbortController: AbortController | null = null;

    // Performance optimizations
    private debounceTimers: Map<string, ReturnType<typeof setTimeout>> = new Map();
    private cachedElements: Map<string, HTMLElement> = new Map();

    // DOM elements
    private mainImage!: HTMLImageElement;
    private loadingSpinner!: HTMLElement;
    private errorMessage!: HTMLElement;
    private sourceButton!: HTMLButtonElement;
    private sourceDropdown!: HTMLElement;
    private currentSourceSpan!: HTMLElement;
    private rewindButton!: HTMLButtonElement;
    private refreshButton!: HTMLButtonElement;
    private heartButton!: HTMLButtonElement;
    private safariButton!: HTMLButtonElement;
    private imageContainer!: HTMLElement;
    private swipeHint!: HTMLElement;
    private container!: HTMLElement;
    private keyboardHint!: HTMLElement;
    private dropdownBackdrop!: HTMLElement;

    constructor() {
      this.initializeElements();
      this.setupEventListeners();
      this.loadSavedSource();
      this.populateSourceDropdown(); // This will set the correct active state
      this.loadNewImageDirect(); // Load first image directly, then start preloading
      this.showSwipeHint();
      
      // Cleanup on page unload
      window.addEventListener('beforeunload', () => this.cleanup());
    }

    private cleanup(): void {
      // Cancel any ongoing preloading
      if (this.preloadAbortController) {
        this.preloadAbortController.abort();
      }
      
      // Clear all debounce timers
      for (const timer of this.debounceTimers.values()) {
        clearTimeout(timer);
      }
      this.debounceTimers.clear();
      
      // Clear caches
      this.preloadedImages.clear();
      this.cachedElements.clear();
      
      // Reset flags
      this.isPreloading = false;
      this.isLoading = false;
    }

    // Preloading system methods
    private async preloadImagesInBackground(): Promise<void> {
      // Prevent multiple concurrent preloading sessions
      if (this.isPreloading) return;
      
      // Cancel any existing preloading
      if (this.preloadAbortController) {
        this.preloadAbortController.abort();
      }
      
      this.preloadAbortController = new AbortController();
      this.isPreloading = true;
      
      try {
        while (this.preloadedImages.size < this.maxPreloadedImages && !this.preloadAbortController.signal.aborted) {
          const imageData = await ImageApiService.fetchImageFromSource(this.currentSource);
          
          if (this.preloadAbortController.signal.aborted) break;
          
          // Check if we already have this image
          if (!this.preloadedImages.has(imageData.url)) {
            // Preload the actual image
            await this.preloadImage(imageData, this.preloadAbortController.signal);
            
            if (!this.preloadAbortController.signal.aborted) {
              this.preloadedImages.set(imageData.url, imageData);
            }
          }
        }
      } catch (error) {
        if (!this.preloadAbortController?.signal.aborted) {
          console.warn('Failed to preload image:', error);
          // Wait before retrying
          await new Promise(resolve => setTimeout(resolve, 1000));
        }
      } finally {
        this.isPreloading = false;
      }
    }

    private async preloadImage(imageData: ImageData, signal?: AbortSignal): Promise<void> {
      return new Promise((resolve, reject) => {
        const img = new Image();
        
        const cleanup = () => {
          img.onload = null;
          img.onerror = null;
        };
        
        img.onload = () => {
          cleanup();
          resolve();
        };
        
        img.onerror = () => {
          cleanup();
          reject(new Error('Failed to preload image'));
        };
        
        // Handle abort signal
        if (signal) {
          signal.addEventListener('abort', () => {
            cleanup();
            reject(new Error('Preload aborted'));
          });
        }
        
        img.src = imageData.url;
      });
    }

    private getPreloadedImage(): ImageData | null {
      // Get the first available preloaded image
      for (const [url, imageData] of this.preloadedImages) {
        this.preloadedImages.delete(url);
        
        // Debounce preloading restart
        this.debounce('preload', () => {
          this.preloadImagesInBackground();
        }, 200);
        
        return imageData;
      }
      return null;
    }

    // Performance utility methods
    private debounce(key: string, func: Function, delay: number): void {
      const existingTimer = this.debounceTimers.get(key);
      if (existingTimer) {
        clearTimeout(existingTimer);
      }
      
      const timer = setTimeout(() => {
        func();
        this.debounceTimers.delete(key);
      }, delay);
      
      this.debounceTimers.set(key, timer);
    }

    private getElement<T extends HTMLElement>(id: string): T {
      const cached = this.cachedElements.get(id) as T;
      if (cached) return cached;
      
      const element = document.getElementById(id) as T;
      this.cachedElements.set(id, element);
      return element;
    }

    private initializeElements(): void {
      this.mainImage = document.getElementById('mainImage') as HTMLImageElement;
      this.loadingSpinner = document.getElementById('loadingSpinner') as HTMLElement;
      this.errorMessage = document.getElementById('errorMessage') as HTMLElement;
      this.sourceButton = document.getElementById('sourceButton') as HTMLButtonElement;
      this.sourceDropdown = document.getElementById('sourceDropdown') as HTMLElement;
      this.currentSourceSpan = document.getElementById('currentSource') as HTMLElement;
      this.rewindButton = document.getElementById('rewindButton') as HTMLButtonElement;
      this.refreshButton = document.getElementById('refreshButton') as HTMLButtonElement;
      this.heartButton = document.getElementById('heartButton') as HTMLButtonElement;
      this.safariButton = document.getElementById('safariButton') as HTMLButtonElement;
      this.imageContainer = document.getElementById('imageContainer') as HTMLElement;
      this.swipeHint = document.getElementById('swipeHint') as HTMLElement;
      this.container = document.getElementById('container') as HTMLElement;
      this.keyboardHint = document.getElementById('keyboardHint') as HTMLElement;
      this.dropdownBackdrop = document.getElementById('dropdownBackdrop') as HTMLElement;
    }

    private setupEventListeners(): void {
      // Button event listeners
      this.refreshButton.addEventListener('click', () => this.loadNewImage());
      this.rewindButton.addEventListener('click', () => this.goToPreviousImage());
      this.heartButton.addEventListener('click', () => this.downloadImage());
      this.safariButton.addEventListener('click', () => this.openInNewTab());

      // Source selector
      this.sourceButton.addEventListener('click', (e) => {
        e.stopPropagation();
        this.toggleSourceDropdown();
      });

      // Close dropdown when clicking outside
      document.addEventListener('click', () => {
        this.closeSourceDropdown();
      });

      // Close dropdown when clicking backdrop
      this.dropdownBackdrop.addEventListener('click', () => {
        this.closeSourceDropdown();
      });

      // Keyboard event listeners
      document.addEventListener('keydown', (e) => this.handleKeyPress(e));

      // Touch event listeners for swipe
      this.imageContainer.addEventListener('touchstart', (e) => this.handleTouchStart(e));
      this.imageContainer.addEventListener('touchend', (e) => this.handleTouchEnd(e));

      // Mouse events for desktop swipe simulation
      this.imageContainer.addEventListener('mousedown', (e) => this.handleMouseDown(e));
      this.imageContainer.addEventListener('mouseup', (e) => this.handleMouseUp(e));

      // Prevent context menu on long press
      this.imageContainer.addEventListener('contextmenu', (e) => e.preventDefault());
    }

    private updateSourceButton(): void {
      this.currentSourceSpan.textContent = ImageApiService.getSourceDisplayName(this.currentSource);
    }

    private updateDropdownActiveState(): void {
      // Remove active class from all options
      const options = this.sourceDropdown.querySelectorAll('.source-option');
      options.forEach(option => option.classList.remove('active'));
      
      // Add active class to current source option
      const currentOption = this.sourceDropdown.querySelector(`[data-source="${this.currentSource}"]`);
      if (currentOption) {
        currentOption.classList.add('active');
      }
    }

    private populateSourceDropdown(): void {
      const sources = ImageApiService.getAllSources();
      this.sourceDropdown.innerHTML = '';

      // Ensure the button text matches the current source
      this.updateSourceButton();

      sources.forEach(source => {
        const option = document.createElement('div');
        option.className = 'source-option';
        option.textContent = ImageApiService.getSourceDisplayName(source);
        option.dataset.source = source;
        
        if (source === this.currentSource) {
          option.classList.add('active');
        }

        option.addEventListener('click', () => this.selectSource(source));
        this.sourceDropdown.appendChild(option);
      });
    }

    private toggleSourceDropdown(): void {
      const isActive = this.sourceDropdown.classList.contains('active');
      
      if (isActive) {
        this.closeSourceDropdown();
      } else {
        this.openSourceDropdown();
      }
    }

    private openSourceDropdown(): void {
      this.sourceDropdown.classList.add('active');
      this.dropdownBackdrop.classList.add('active');
      this.container.classList.add('dropdown-active');
    }

    private closeSourceDropdown(): void {
      this.sourceDropdown.classList.remove('active');
      this.dropdownBackdrop.classList.remove('active');
      this.container.classList.remove('dropdown-active');
    }

    private selectSource(source: ImageSource): void {
      // Prevent unnecessary work if same source
      if (source === this.currentSource) {
        this.closeSourceDropdown();
        return;
      }
      
      this.currentSource = source;
      this.updateSourceButton();
      this.updateDropdownActiveState(); // Update visual selection in dropdown
      this.saveSelectedSource();
      this.closeSourceDropdown();
      
      // Cancel any ongoing preloading for old source
      if (this.preloadAbortController) {
        this.preloadAbortController.abort();
      }
      
      // Clear preloaded images for old source
      this.preloadedImages.clear();
      
      // Load first image immediately without preloading delay
      this.loadNewImageDirect();
    }

    private loadSavedSource(): void {
      const savedSource = localStorage.getItem('selectedSource');
      if (savedSource && Object.values(ImageSource).includes(savedSource as ImageSource)) {
        this.currentSource = savedSource as ImageSource;
        this.updateSourceButton();
      }
    }

    private saveSelectedSource(): void {
      localStorage.setItem('selectedSource', this.currentSource);
    }

    private async loadNewImageDirect(): Promise<void> {
      if (this.isLoading) return;

      // Load image directly without checking preloaded images
      this.showLoading();
      this.hideError();

      try {
        const imageData = await ImageApiService.fetchImageFromSource(this.currentSource);
        await this.loadImage(imageData);
        
        // Start preloading in background after first image is loaded
        setTimeout(() => {
          this.preloadImagesInBackground();
        }, 100);
      } catch (error) {
        console.error('Error loading image:', error);
        this.showError();
      }
    }

    private async loadNewImage(): Promise<void> {
      if (this.isLoading) return;

      // Try to get a preloaded image first for instant loading
      const preloadedImage = this.getPreloadedImage();
      
      if (preloadedImage) {
        // Use preloaded image for instant display
        await this.loadImage(preloadedImage);
        return;
      }

      // Fallback to loading new image if no preloaded images available
      this.showLoading();
      this.hideError();

      try {
        const imageData = await ImageApiService.fetchImageFromSource(this.currentSource);
        await this.loadImage(imageData);
      } catch (error) {
        console.error('Error loading image:', error);
        this.showError();
      }
    }

    private showLoading(): void {
      if (this.isLoading) return; // Prevent redundant calls
      
      this.isLoading = true;
      
      // Batch DOM updates using requestAnimationFrame
      requestAnimationFrame(() => {
        this.loadingSpinner.style.display = 'block';
        this.mainImage.style.display = 'none';
        this.refreshButton.disabled = true;
      });
    }

    private hideLoading(): void {
      if (!this.isLoading) return; // Prevent redundant calls
      
      this.isLoading = false;
      
      // Batch DOM updates using requestAnimationFrame
      requestAnimationFrame(() => {
        this.loadingSpinner.style.display = 'none';
        this.refreshButton.disabled = false;
      });
    }

    private showError(): void {
      this.hideLoading();
      
      requestAnimationFrame(() => {
        this.errorMessage.style.display = 'block';
        this.mainImage.style.display = 'none';
      });
    }

    private hideError(): void {
      requestAnimationFrame(() => {
        this.errorMessage.style.display = 'none';
      });
    }

    private async loadImage(imageData: ImageData): Promise<void> {
      return new Promise((resolve, reject) => {
        const img = new Image();
        
        const cleanup = () => {
          img.onload = null;
          img.onerror = null;
        };
        
        img.onload = () => {
          // Use requestAnimationFrame for smooth DOM updates
          requestAnimationFrame(() => {
            this.mainImage.src = img.src;
            this.mainImage.style.display = 'block';
            this.hideLoading();
            this.hideError();

            // Add to history if not already the last image
            const historyItem: ImageHistoryItem = {
              ...imageData,
              timestamp: Date.now()
            };

            if (this.imageHistory.length === 0 || 
                this.imageHistory[this.imageHistory.length - 1].url !== imageData.url) {
              this.imageHistory.push(historyItem);
              
              // Limit history size to prevent memory bloat
              if (this.imageHistory.length > 50) {
                this.imageHistory = this.imageHistory.slice(-30);
                this.currentImageIndex = Math.min(this.currentImageIndex, this.imageHistory.length - 1);
              }
            }

            this.currentImageIndex = this.imageHistory.length - 1;
            this.updateNavigationButtons();
            
            // Debounce preloading continuation
            this.debounce('continue-preload', () => {
              this.preloadImagesInBackground();
            }, 500);
            
            cleanup();
            resolve();
          });
        };

        img.onerror = () => {
          cleanup();
          this.showError();
          reject(new Error('Failed to load image'));
        };

        img.src = imageData.url;
      });
    }

    private goToPreviousImage(): void {
      if (this.imageHistory.length === 0 || this.currentImageIndex <= 0) {
        return;
      }

      this.currentImageIndex--;
      const previousImage = this.imageHistory[this.currentImageIndex];
      
      this.mainImage.src = previousImage.url;
      this.updateNavigationButtons();
    }

    private goToNextImageOrLoadNew(): void {
      if (this.imageHistory.length === 0) {
        // No history, load new image
        this.loadNewImage();
        return;
      }

      if (this.currentImageIndex < this.imageHistory.length - 1) {
        // We can go forward in history
        this.currentImageIndex++;
        const nextImage = this.imageHistory[this.currentImageIndex];
        this.mainImage.src = nextImage.url;
        this.updateNavigationButtons();
      } else {
        // We're at the newest image, load a new one
        this.loadNewImage();
      }
    }

    private updateNavigationButtons(): void {
      // Rewind button is disabled when at the first image or no history
      this.rewindButton.disabled = this.imageHistory.length === 0 || this.currentImageIndex <= 0;
      
      // Safari button is disabled when no current image
      this.safariButton.disabled = this.currentImageIndex < 0 || this.currentImageIndex >= this.imageHistory.length;
    }

    private downloadImage(): void {
      if (this.currentImageIndex < 0 || this.currentImageIndex >= this.imageHistory.length) {
        return;
      }

      const currentImage = this.imageHistory[this.currentImageIndex];
      const link = document.createElement('a');
      link.href = currentImage.url;
      link.download = `anime_image_${Date.now()}.jpg`;
      link.target = '_blank';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }

    private openInNewTab(): void {
      if (this.currentImageIndex < 0 || this.currentImageIndex >= this.imageHistory.length) {
        return;
      }

      const currentImage = this.imageHistory[this.currentImageIndex];
      window.open(currentImage.url, '_blank');
    }

    private handleKeyPress(event: KeyboardEvent): void {
      // Ignore if user is typing in an input
      if (event.target instanceof HTMLInputElement || event.target instanceof HTMLTextAreaElement) {
        return;
      }

      switch (event.key.toLowerCase()) {
        case 'a':
        case 'arrowleft':
          event.preventDefault();
          this.goToPreviousImage();
          break;
        case 'd':
        case 'arrowright':
          event.preventDefault();
          this.goToNextImageOrLoadNew();
          break;
        case 'w':
        case 'arrowup':
          event.preventDefault();
          if (!this.isFullscreen) {
            this.toggleFullscreen(true);
          }
          break;
        case 's':
        case 'arrowdown':
          event.preventDefault();
          this.toggleFullscreen(false);
          break;
        case 'f':
          event.preventDefault();
          this.downloadImage();
          break;
        case 'escape':
          event.preventDefault();
          this.toggleFullscreen(false);
          break;
      }
    }

    private handleTouchStart(event: TouchEvent): void {
      this.touchStartX = event.changedTouches[0].screenX;
    }

    private handleTouchEnd(event: TouchEvent): void {
      this.touchEndX = event.changedTouches[0].screenX;
      // Throttle swipe handling
      this.debounce('swipe', () => {
        this.handleSwipe();
      }, 50);
    }

    private handleMouseDown(event: MouseEvent): void {
      this.touchStartX = event.screenX;
    }

    private handleMouseUp(event: MouseEvent): void {
      this.touchEndX = event.screenX;
      // Throttle swipe handling
      this.debounce('swipe', () => {
        this.handleSwipe();
      }, 50);
    }

    private handleSwipe(): void {
      const swipeThreshold = 50;
      const swipeDistance = this.touchEndX - this.touchStartX;

      if (Math.abs(swipeDistance) > swipeThreshold) {
        if (swipeDistance > 0) {
          // Swipe right - go to previous image
          this.goToPreviousImage();
        } else {
          // Swipe left - go to next image or load new
          this.goToNextImageOrLoadNew();
        }
      }
    }

    private toggleFullscreen(enable: boolean): void {
      this.isFullscreen = enable;
      
      if (enable) {
        document.body.style.overflow = 'hidden';
        this.container.style.display = 'none';
        this.keyboardHint.style.display = 'none';
        
        // Create fullscreen main content
        const fullscreenContent = document.createElement('div');
        fullscreenContent.className = 'main-content fullscreen';
        fullscreenContent.id = 'fullscreenContent';
        
        // Clone and move image container to fullscreen content
        const clonedContainer = this.imageContainer.cloneNode(true) as HTMLElement;
        clonedContainer.classList.add('fullscreen');
        const clonedImage = clonedContainer.querySelector('.main-image') as HTMLImageElement;
        if (clonedImage) {
          clonedImage.classList.add('fullscreen');
        }
        
        fullscreenContent.appendChild(clonedContainer);
        document.body.appendChild(fullscreenContent);
        
        // Hide original image container
        this.imageContainer.style.display = 'none';
      } else {
        document.body.style.overflow = '';
        this.container.style.display = 'flex';
        this.keyboardHint.style.display = 'block';
        this.imageContainer.style.display = 'flex';
        
        // Remove fullscreen content
        const fullscreenContent = document.getElementById('fullscreenContent');
        if (fullscreenContent) {
          fullscreenContent.remove();
        }
      }
    }

    private showSwipeHint(): void {
      this.swipeHint.classList.add('show');
      setTimeout(() => {
        this.swipeHint.classList.remove('show');
      }, 3000);
    }

    private showAlert(message: string): void {
      // Create a temporary alert
      const alert = document.createElement('div');
      alert.textContent = message;
      alert.style.cssText = `
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(255, 0, 0, 0.9);
        color: white;
        padding: 1rem 2rem;
        border-radius: 10px;
        z-index: 20000;
        font-size: 0.9rem;
        max-width: 80%;
        text-align: center;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      `;
      
      document.body.appendChild(alert);
      
      setTimeout(() => {
        if (alert.parentNode) {
          alert.parentNode.removeChild(alert);
        }
      }, 3000);
    }
  }

  // Initialize the app when DOM is loaded
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => new AnimeImageViewer());
  } else {
    new AnimeImageViewer();
  }
</script>
