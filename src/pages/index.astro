---
import Layout from '../layouts/Layout.astro';
---

<Layout title="AniGen">
  <div class="container" id="container">
    <header class="header">
      <h1 class="title text-gradient">Anime Image API</h1>
      <div class="source-selector">
        <button class="source-button" id="sourceButton">
          <span id="currentSource">waifuPics</span> ▼
        </button>
        <div class="source-dropdown" id="sourceDropdown">
          <!-- Sources will be populated by JavaScript -->
        </div>
      </div>
    </header>

    <main class="main-content" id="mainContent">
      <div class="image-container" id="imageContainer">
        <img 
          class="main-image"
          id="mainImage" 
          alt="Anime image"
          style="display: none;"
        />
        <div class="loading-spinner" id="loadingSpinner"></div>
        <div class="error-message" id="errorMessage" style="display: none;">
          Failed to load image. Please try again.
        </div>
        <div class="swipe-hint" id="swipeHint">
          <!-- Text will be set by JavaScript based on device type -->
        </div>
      </div>
    </main>

    <div class="controls">
      <button class="control-button primary" id="rewindButton" title="Previous image (A key)" disabled>
        ⏪
      </button>
      <button class="control-button primary" id="refreshButton" title="Next image (D key)">
        ⏩
      </button>
      <button class="control-button primary" id="heartButton" title="Download image (F key)">
        ❤️
      </button>
    </div>

    <div class="keyboard-hint" id="keyboardHint">
      A: Previous | D: Next/New | W: Fullscreen | S: Exit Fullscreen | F: Download
    </div>

    <footer class="footer-text">
      <p>made with <a href="https://github.com/withastro/astro" target="_blank" class="text-gradient">Astro</a> and much ❤️ by <span id="mlemorsText" class="tap-target">mlemors</span></p>
    </footer>

    <!-- Dropdown backdrop -->
    <div class="dropdown-backdrop" id="dropdownBackdrop"></div>
  </div>
</Layout>

<script>
  import { ImageSource, ImageApiService, type ImageData } from '../services/imageApis';

  interface ImageHistoryItem extends ImageData {
    timestamp: number;
  }

  class AnimeImageViewer {
    private currentSource: ImageSource = ImageSource.WAIFU_PICS;
    private imageHistory: ImageHistoryItem[] = [];
    private currentImageIndex: number = -1;
    private isLoading: boolean = false;
    private touchStartX: number = 0;
    private touchEndX: number = 0;
    private isFullscreen: boolean = false;
    
    // Preloading system
    private preloadedImages: Map<string, ImageData> = new Map();
    private maxPreloadedImages: number = 3;
    private isPreloading: boolean = false;
    private preloadAbortController: AbortController | null = null;

    // Performance optimizations
    private debounceTimers: Map<string, ReturnType<typeof setTimeout>> = new Map();
    private cachedElements: Map<string, HTMLElement> = new Map();

    // explicit mode activation
    private tapCount: number = 0;
    private tapTimer: ReturnType<typeof setTimeout> | null = null;
    private isExplicitMode: boolean = false;

    // UI state
    private keyboardHintVisible: boolean = true;
    private isMobileDevice: boolean = false;

    // Cinema mode background
    private canvas: HTMLCanvasElement;
    private ctx: CanvasRenderingContext2D;
    private currentColors: string[] = ['#1a1a1a', '#2a2a2a'];

    // DOM elements
    private mainImage!: HTMLImageElement;
    private loadingSpinner!: HTMLElement;
    private errorMessage!: HTMLElement;
    private sourceButton!: HTMLButtonElement;
    private sourceDropdown!: HTMLElement;
    private currentSourceSpan!: HTMLElement;
    private rewindButton!: HTMLButtonElement;
    private nextButton!: HTMLButtonElement;
    private heartButton!: HTMLButtonElement;
    private imageContainer!: HTMLElement;
    private swipeHint!: HTMLElement;
    private container!: HTMLElement;
    private keyboardHint!: HTMLElement;
    private dropdownBackdrop!: HTMLElement;
    private mlemorsText!: HTMLElement;

    constructor() {
      // Initialize canvas for color extraction
      this.canvas = document.createElement('canvas');
      this.ctx = this.canvas.getContext('2d')!;
      
      // Detect device type
      this.detectDeviceType();
      
      this.initializeElements();
      this.setupEventListeners();
      this.loadSavedSource();
      this.loadExplicitMode();
      this.populateSourceDropdown(); // This will set the correct active state
      this.loadNewImageDirect(); // Load first image directly, then start preloading
      this.showSwipeHint();
      
      // Cleanup on page unload
      window.addEventListener('beforeunload', () => this.cleanup());
    }

    private cleanup(): void {
      // Cancel any ongoing preloading
      if (this.preloadAbortController) {
        this.preloadAbortController.abort();
      }
      
      // Clear all debounce timers
      for (const timer of this.debounceTimers.values()) {
        clearTimeout(timer);
      }
      this.debounceTimers.clear();
      
      // Clear tap timer
      if (this.tapTimer) {
        clearTimeout(this.tapTimer);
      }
      
      // Clear caches
      this.preloadedImages.clear();
      this.cachedElements.clear();
      
      // Reset flags
      this.isPreloading = false;
      this.isLoading = false;
      this.tapCount = 0;
    }

    private detectDeviceType(): void {
      // Check for touch support and mobile user agents
      const hasTouchSupport = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
      const isMobileUserAgent = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      const isSmallScreen = window.innerWidth <= 768;
      
      // Consider it mobile if it has touch support AND (mobile user agent OR small screen)
      this.isMobileDevice = hasTouchSupport && (isMobileUserAgent || isSmallScreen);
    }

    // Preloading system methods
    private async preloadImagesInBackground(): Promise<void> {
      // Prevent multiple concurrent preloading sessions
      if (this.isPreloading) return;
      
      // Cancel any existing preloading
      if (this.preloadAbortController) {
        this.preloadAbortController.abort();
      }
      
      this.preloadAbortController = new AbortController();
      this.isPreloading = true;
      
      try {
        // More aggressive preloading - increase limit and parallel requests
        const targetPreloadCount = Math.min(this.maxPreloadedImages * 1.5, 8);
        
        while (this.preloadedImages.size < targetPreloadCount && !this.preloadAbortController.signal.aborted) {
          // Preload 2 images in parallel for faster loading
          const preloadPromises = [];
          for (let i = 0; i < 2 && this.preloadedImages.size + i < targetPreloadCount; i++) {
            preloadPromises.push(this.fetchAndPreloadSingleImage());
          }
          
          await Promise.allSettled(preloadPromises);
          
          if (this.preloadAbortController.signal.aborted) break;
        }
      } catch (error) {
        if (!this.preloadAbortController?.signal.aborted) {
          console.warn('Failed to preload image:', error);
          // Shorter wait before retrying for faster recovery
          await new Promise(resolve => setTimeout(resolve, 500));
        }
      } finally {
        this.isPreloading = false;
      }
    }

    private async fetchAndPreloadSingleImage(): Promise<void> {
      try {
        const imageData = await ImageApiService.fetchImageFromSource(this.currentSource);
        
        if (this.preloadAbortController?.signal.aborted) return;
        
        // Check if we already have this image
        if (!this.preloadedImages.has(imageData.url)) {
          // Preload the actual image with timeout
          await this.preloadImage(imageData, this.preloadAbortController?.signal);
          
          if (!this.preloadAbortController?.signal.aborted) {
            this.preloadedImages.set(imageData.url, imageData);
          }
        }
      } catch (error) {
        // Silently handle individual preload failures
        console.warn('Individual preload failed:', error);
      }
    }

    private async preloadImage(imageData: ImageData, signal?: AbortSignal): Promise<void> {
      return new Promise((resolve, reject) => {
        const img = new Image();
        
        // Shorter timeout for preloading to avoid blocking
        const timeout = setTimeout(() => {
          cleanup();
          reject(new Error('Preload timeout'));
        }, 8000); // 8 second timeout for preloading
        
        const cleanup = () => {
          img.onload = null;
          img.onerror = null;
          clearTimeout(timeout);
        };
        
        // Optimize preloading
        img.decoding = 'async';
        img.loading = 'eager';
        
        img.onload = () => {
          cleanup();
          resolve();
        };
        
        img.onerror = () => {
          cleanup();
          reject(new Error('Failed to preload image'));
        };
        
        // Handle abort signal
        if (signal) {
          signal.addEventListener('abort', () => {
            cleanup();
            reject(new Error('Preload aborted'));
          });
        }
        
        img.src = imageData.url;
      });
    }

    private getPreloadedImage(): ImageData | null {
      // Get the first available preloaded image
      for (const [url, imageData] of this.preloadedImages) {
        this.preloadedImages.delete(url);
        
        // Debounce preloading restart
        this.debounce('preload', () => {
          this.preloadImagesInBackground();
        }, 200);
        
        return imageData;
      }
      return null;
    }

    // Performance utility methods
    private debounce(key: string, func: Function, delay: number): void {
      const existingTimer = this.debounceTimers.get(key);
      if (existingTimer) {
        clearTimeout(existingTimer);
      }
      
      const timer = setTimeout(() => {
        func();
        this.debounceTimers.delete(key);
      }, delay);
      
      this.debounceTimers.set(key, timer);
    }

    // Cinema mode background methods
    private extractDominantColors(img: HTMLImageElement): string[] {
      try {
        // Use smaller canvas for faster processing
        this.canvas.width = 50;
        this.canvas.height = 50;
        
        // Clear canvas
        this.ctx.clearRect(0, 0, 50, 50);
        
        // Draw image to canvas
        this.ctx.drawImage(img, 0, 0, 50, 50);
        
        // Get image data
        const imageData = this.ctx.getImageData(0, 0, 50, 50);
        const data = imageData.data;
        
        // Fast color counting with less precision but better performance
        const colorCounts: Map<string, number> = new Map();
        
        // Sample every 8th pixel for much faster processing
        for (let i = 0; i < data.length; i += 32) { // Every 8th pixel (4 * 8)
          const r = data[i];
          const g = data[i + 1];
          const b = data[i + 2];
          const alpha = data[i + 3];
          
          // Skip transparent or very dark pixels
          if (alpha < 128 || (r < 30 && g < 30 && b < 30)) continue;
          
          // Larger buckets for faster grouping
          const rBucket = Math.floor(r / 40) * 40;
          const gBucket = Math.floor(g / 40) * 40;
          const bBucket = Math.floor(b / 40) * 40;
          
          const color = `${rBucket},${gBucket},${bBucket}`;
          colorCounts.set(color, (colorCounts.get(color) || 0) + 1);
        }
        
        // Get top 2 colors quickly
        const sortedColors = Array.from(colorCounts.entries())
          .sort((a, b) => b[1] - a[1])
          .slice(0, 2)
          .map(([color]) => {
            const [r, g, b] = color.split(',').map(Number);
            return this.darkenColor(`rgb(${r}, ${g}, ${b})`);
          });
        
        // Ensure we have 2 colors
        if (sortedColors.length < 2) {
          sortedColors.push('#2a1a1a', '#1a2a2a');
        }
        
        return sortedColors.slice(0, 2);
        
      } catch (error) {
        console.warn('Failed to extract colors:', error);
        // Return some variety in fallback colors
        const fallbackColors = [
          ['#2a1a1a', '#1a2a2a'],
          ['#1a2a1a', '#2a1a1a'],
          ['#1a1a2a', '#2a2a1a']
        ];
        return fallbackColors[Math.floor(Math.random() * fallbackColors.length)];
      }
    }
    
    private darkenColor(color: string): string {
      try {
        const rgb = color.match(/\d+/g);
        if (!rgb || rgb.length < 3) return '#2a1a1a';
        
        // Make colors darker but more vibrant for better cinema effect
        const r = Math.max(10, Math.floor(parseInt(rgb[0]) * 0.4));
        const g = Math.max(10, Math.floor(parseInt(rgb[1]) * 0.4));
        const b = Math.max(10, Math.floor(parseInt(rgb[2]) * 0.4));
        
        // Ensure we have some color saturation
        const max = Math.max(r, g, b);
        if (max < 30) {
          // If too dark, add some color bias
          return `rgb(${r + 20}, ${g + 15}, ${b + 25})`;
        }
        
        return `rgb(${r}, ${g}, ${b})`;
      } catch {
        return '#2a1a1a';
      }
    }
    
    private updateBackgroundFromImage(img: HTMLImageElement): void {
      // Ensure image is loaded and has dimensions
      if (!img.complete || img.naturalWidth === 0) {
        img.onload = () => {
          this.updateBackgroundFromImage(img);
        };
        return;
      }
      
      // Extract colors immediately without debouncing
      const colors = this.extractDominantColors(img);
      this.currentColors = colors;
      this.applyBackgroundGradient(colors);
    }
    
    private applyBackgroundGradient(colors: string[]): void {
      try {
        const [color1, color2] = colors;
        
        console.log('Applying background gradient:', color1, color2); // Debug log
        
        // Update CSS custom properties directly on document.documentElement
        document.documentElement.style.setProperty('--dynamic-bg-1', color1);
        document.documentElement.style.setProperty('--dynamic-bg-2', color2);
        
        // Also update body style as fallback
        document.body.style.setProperty('--dynamic-bg-1', color1);
        document.body.style.setProperty('--dynamic-bg-2', color2);
        
        console.log('Background updated successfully'); // Debug log
        
      } catch (error) {
        console.warn('Failed to apply background gradient:', error);
      }
    }

    private getElement<T extends HTMLElement>(id: string): T {
      const cached = this.cachedElements.get(id) as T;
      if (cached) return cached;
      
      const element = document.getElementById(id) as T;
      this.cachedElements.set(id, element);
      return element;
    }

    private initializeElements(): void {
      this.mainImage = document.getElementById('mainImage') as HTMLImageElement;
      this.loadingSpinner = document.getElementById('loadingSpinner') as HTMLElement;
      this.errorMessage = document.getElementById('errorMessage') as HTMLElement;
      this.sourceButton = document.getElementById('sourceButton') as HTMLButtonElement;
      this.sourceDropdown = document.getElementById('sourceDropdown') as HTMLElement;
      this.currentSourceSpan = document.getElementById('currentSource') as HTMLElement;
      this.rewindButton = document.getElementById('rewindButton') as HTMLButtonElement;
      this.nextButton = document.getElementById('refreshButton') as HTMLButtonElement;
      this.heartButton = document.getElementById('heartButton') as HTMLButtonElement;
      this.imageContainer = document.getElementById('imageContainer') as HTMLElement;
      this.swipeHint = document.getElementById('swipeHint') as HTMLElement;
      this.container = document.getElementById('container') as HTMLElement;
      this.keyboardHint = document.getElementById('keyboardHint') as HTMLElement;
      this.dropdownBackdrop = document.getElementById('dropdownBackdrop') as HTMLElement;
      this.mlemorsText = document.getElementById('mlemorsText') as HTMLElement;
    }

    private setupEventListeners(): void {
      // Button event listeners
      this.nextButton.addEventListener('click', () => this.goToNextImageOrLoadNew());
      this.rewindButton.addEventListener('click', () => this.goToPreviousImage());
      this.heartButton.addEventListener('click', () => this.downloadImage());

      // Source selector
      this.sourceButton.addEventListener('click', (e) => {
        e.stopPropagation();
        this.toggleSourceDropdown();
      });

      // Close dropdown when clicking outside
      document.addEventListener('click', () => {
        this.closeSourceDropdown();
      });

      // Close dropdown when clicking backdrop
      this.dropdownBackdrop.addEventListener('click', () => {
        this.closeSourceDropdown();
      });

      // Keyboard event listeners
      document.addEventListener('keydown', (e) => this.handleKeyPress(e));

      // Touch event listeners for swipe
      this.imageContainer.addEventListener('touchstart', (e) => this.handleTouchStart(e));
      this.imageContainer.addEventListener('touchend', (e) => this.handleTouchEnd(e));

      // Mouse events for desktop swipe simulation
      this.imageContainer.addEventListener('mousedown', (e) => this.handleMouseDown(e));
      this.imageContainer.addEventListener('mouseup', (e) => this.handleMouseUp(e));

      // Prevent context menu on long press
      this.imageContainer.addEventListener('contextmenu', (e) => e.preventDefault());

      this.mlemorsText.addEventListener('click', () => this.handleMlemorsTap());
    }

    private updateSourceButton(): void {
      this.currentSourceSpan.textContent = ImageApiService.getSourceDisplayName(this.currentSource);
    }

    private updateDropdownActiveState(): void {
      // Remove active class from all options
      const options = this.sourceDropdown.querySelectorAll('.source-option');
      options.forEach(option => option.classList.remove('active'));
      
      // Add active class to current source option
      const currentOption = this.sourceDropdown.querySelector(`[data-source="${this.currentSource}"]`);
      if (currentOption) {
        currentOption.classList.add('active');
      }
    }

    private populateSourceDropdown(): void {
      const sources = ImageApiService.getAllSources();
      this.sourceDropdown.innerHTML = '';

      // Ensure the button text matches the current source
      this.updateSourceButton();

      sources.forEach(source => {
        const option = document.createElement('div');
        option.className = 'source-option';
        option.textContent = ImageApiService.getSourceDisplayName(source);
        option.dataset.source = source;
        
        if (source === this.currentSource) {
          option.classList.add('active');
        }

        option.addEventListener('click', () => this.selectSource(source));
        this.sourceDropdown.appendChild(option);
      });
    }

    private toggleSourceDropdown(): void {
      const isActive = this.sourceDropdown.classList.contains('active');
      
      if (isActive) {
        this.closeSourceDropdown();
      } else {
        this.openSourceDropdown();
      }
    }

    private openSourceDropdown(): void {
      this.sourceDropdown.classList.add('active');
      this.dropdownBackdrop.classList.add('active');
      this.container.classList.add('dropdown-active');
    }

    private closeSourceDropdown(): void {
      this.sourceDropdown.classList.remove('active');
      this.dropdownBackdrop.classList.remove('active');
      this.container.classList.remove('dropdown-active');
    }

    private selectSource(source: ImageSource): void {
      // Prevent unnecessary work if same source
      if (source === this.currentSource) {
        this.closeSourceDropdown();
        return;
      }
      
      this.currentSource = source;
      this.updateSourceButton();
      this.updateDropdownActiveState(); // Update visual selection in dropdown
      this.saveSelectedSource();
      this.closeSourceDropdown();
      
      // Cancel any ongoing preloading for old source
      if (this.preloadAbortController) {
        this.preloadAbortController.abort();
      }
      
      // Clear preloaded images for old source
      this.preloadedImages.clear();
      
      // Load first image immediately without preloading delay
      this.loadNewImageDirect();
    }

    private loadSavedSource(): void {
      const savedSource = localStorage.getItem('selectedSource');
      if (savedSource && Object.values(ImageSource).includes(savedSource as ImageSource)) {
        this.currentSource = savedSource as ImageSource;
        this.updateSourceButton();
      }
    }

    private loadExplicitMode(): void {
      this.isExplicitMode = ImageApiService.getExplicitMode();
    }

    private handleMlemorsTap(): void {
      this.tapCount++;
      
      // Clear existing timer
      if (this.tapTimer) {
        clearTimeout(this.tapTimer);
      }
      
      if (this.tapCount >= 5) {
        this.toggleExplicitMode();
        this.tapCount = 0;
      } else {
        // Reset tap count after 2 seconds
        this.tapTimer = setTimeout(() => {
          this.tapCount = 0;
        }, 2000);
      }
    }

    private toggleExplicitMode(): void {
      const wasExplicitMode = this.isExplicitMode;
      this.isExplicitMode = !this.isExplicitMode;
      ImageApiService.setExplicitMode(this.isExplicitMode);

      const message = this.isExplicitMode
        ? '🔞 NSFW Mode Activated!'
        : '✅ NSFW Mode Deactivated';
      
      this.showAlert(message, this.isExplicitMode ? '#ff6b6b' : '#4CAF50');
      
      // Clear preloaded images and reload with new mode
      this.preloadedImages.clear();
      if (this.preloadAbortController) {
        this.preloadAbortController.abort();
      }

      // If deactivating explicit mode, immediately clear history and load new SFW image
      if (wasExplicitMode && !this.isExplicitMode) {
        // Clear all explicit content from history
        this.imageHistory = [];
        this.currentImageIndex = 0;
        
        // Immediately load a new SFW image to replace any explicit content
        this.debounce('loadNewImage', () => {
          this.loadNewImage();
        }, 100);
      }
    }

    private saveSelectedSource(): void {
      localStorage.setItem('selectedSource', this.currentSource);
    }

    private async loadNewImageDirect(): Promise<void> {
      if (this.isLoading) return;

      // Load image directly without checking preloaded images
      this.showLoading();
      this.hideError();

      try {
        const imageData = await ImageApiService.fetchImageFromSource(this.currentSource);
        await this.loadImage(imageData);
        
        // Start preloading in background after first image is loaded
        setTimeout(() => {
          this.preloadImagesInBackground();
        }, 100);
      } catch (error) {
        console.error('Error loading image:', error);
        this.showError();
      }
    }

    private async loadNewImage(): Promise<void> {
      if (this.isLoading) return;

      // Try to get a preloaded image first for instant loading
      const preloadedImage = this.getPreloadedImage();
      
      if (preloadedImage) {
        // Use preloaded image for instant display
        await this.loadImage(preloadedImage);
        return;
      }

      // Fallback to loading new image if no preloaded images available
      this.showLoading();
      this.hideError();

      try {
        const imageData = await ImageApiService.fetchImageFromSource(this.currentSource);
        await this.loadImage(imageData);
      } catch (error) {
        console.error('Error loading image:', error);
        this.showError();
      }
    }

    private showLoading(): void {
      if (this.isLoading) return; // Prevent redundant calls
      
      this.isLoading = true;
      
      // Batch DOM updates using requestAnimationFrame
      requestAnimationFrame(() => {
        this.loadingSpinner.style.display = 'block';
        this.mainImage.style.display = 'none';
        this.nextButton.disabled = true;
      });
    }

    private hideLoading(): void {
      if (!this.isLoading) return; // Prevent redundant calls
      
      this.isLoading = false;
      
      // Batch DOM updates using requestAnimationFrame
      requestAnimationFrame(() => {
        this.loadingSpinner.style.display = 'none';
        this.nextButton.disabled = false;
      });
    }

    private showError(): void {
      this.hideLoading();
      
      requestAnimationFrame(() => {
        this.errorMessage.style.display = 'block';
        this.mainImage.style.display = 'none';
      });
    }

    private hideError(): void {
      requestAnimationFrame(() => {
        this.errorMessage.style.display = 'none';
      });
    }

    private async loadImage(imageData: ImageData): Promise<void> {
      return new Promise((resolve, reject) => {
        const img = new Image();
        
        // Add timeout for slow-loading images
        const timeout = setTimeout(() => {
          cleanup();
          console.warn(`Image loading timeout for: ${imageData.url}`);
          reject(new Error('Image loading timeout'));
        }, 15000); // 15 second timeout
        
        const cleanup = () => {
          img.onload = null;
          img.onerror = null;
          clearTimeout(timeout);
        };
        
        // Optimize image loading with hints
        img.decoding = 'async';
        img.loading = 'eager';
        
        img.onload = () => {
          cleanup();
          
          // Use requestAnimationFrame for smooth DOM updates
          requestAnimationFrame(() => {
            this.mainImage.src = img.src;
            this.mainImage.style.display = 'block';
            this.hideLoading();
            this.hideError();

            // Update background immediately after image is set
            this.updateBackgroundFromImage(this.mainImage);

            // Add to history if not already the last image
            const historyItem: ImageHistoryItem = {
              ...imageData,
              timestamp: Date.now()
            };

            if (this.imageHistory.length === 0 || 
                this.imageHistory[this.imageHistory.length - 1].url !== imageData.url) {
              this.imageHistory.push(historyItem);
              
              // Limit history size to prevent memory bloat
              if (this.imageHistory.length > 50) {
                this.imageHistory = this.imageHistory.slice(-30);
                this.currentImageIndex = Math.min(this.currentImageIndex, this.imageHistory.length - 1);
              }
            }

            this.currentImageIndex = this.imageHistory.length - 1;
            this.updateNavigationButtons();
            
            // Debounce preloading continuation
            this.debounce('continue-preload', () => {
              this.preloadImagesInBackground();
            }, 500);
            
            cleanup();
            resolve();
          });
        };

        img.onerror = () => {
          cleanup();
          this.showError();
          reject(new Error('Failed to load image'));
        };

        // Start loading the image
        img.src = imageData.url;
      });
    }

    private goToPreviousImage(): void {
      if (this.imageHistory.length === 0 || this.currentImageIndex <= 0) {
        return;
      }

      this.currentImageIndex--;
      const previousImage = this.imageHistory[this.currentImageIndex];
      
      this.mainImage.src = previousImage.url;
      
      // Update background immediately when image loads
      this.mainImage.onload = () => {
        this.updateBackgroundFromImage(this.mainImage);
      };
      
      this.updateNavigationButtons();
    }

    private goToNextImageOrLoadNew(): void {
      if (this.imageHistory.length === 0) {
        // No history, load new image
        this.loadNewImage();
        return;
      }

      if (this.currentImageIndex < this.imageHistory.length - 1) {
        // We can go forward in history
        this.currentImageIndex++;
        const nextImage = this.imageHistory[this.currentImageIndex];
        this.mainImage.src = nextImage.url;
        
        // Update background immediately when image loads
        this.mainImage.onload = () => {
          this.updateBackgroundFromImage(this.mainImage);
        };
        
        this.updateNavigationButtons();
      } else {
        // We're at the newest image, load a new one
        this.loadNewImage();
      }
    }

    private updateNavigationButtons(): void {
      // Rewind button is disabled when at the first image or no history
      this.rewindButton.disabled = this.imageHistory.length === 0 || this.currentImageIndex <= 0;
    }

    private async downloadImage(): Promise<void> {
      if (this.currentImageIndex < 0 || this.currentImageIndex >= this.imageHistory.length) {
        return;
      }

      const currentImage = this.imageHistory[this.currentImageIndex];
      
      try {
        // For mobile devices (iOS/Android), use different approach
        if (this.isMobileDevice) {
          await this.downloadImageMobile(currentImage);
        } else {
          // For desktop, use traditional download with save dialog
          await this.downloadImageDesktop(currentImage);
        }
      } catch (error) {
        console.warn('Download failed, falling back to simple method:', error);
        this.fallbackDownload(currentImage);
      }
    }

    private async downloadImageDesktop(imageData: ImageData): Promise<void> {
      try {
        // Fetch the image as blob to trigger proper save dialog
        const response = await fetch(imageData.url);
        const blob = await response.blob();
        
        // Create object URL from blob
        const blobUrl = URL.createObjectURL(blob);
        
        // Create download link
        const link = document.createElement('a');
        link.href = blobUrl;
        
        // Generate a better filename
        const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
        const extension = this.getImageExtension(imageData.url);
        link.download = `anime_image_${timestamp}${extension}`;
        
        // Trigger download with save dialog
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        // Clean up blob URL after a delay
        setTimeout(() => {
          URL.revokeObjectURL(blobUrl);
        }, 100);
        
      } catch (error) {
        throw error;
      }
    }

    private async downloadImageMobile(imageData: ImageData): Promise<void> {
      try {
        // For mobile, try to use the Web Share API if available
        if (navigator.share && navigator.canShare) {
          const response = await fetch(imageData.url);
          const blob = await response.blob();
          
          const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
          const extension = this.getImageExtension(imageData.url);
          const filename = `anime_image_${timestamp}${extension}`;
          
          const file = new File([blob], filename, { type: blob.type });
          
          if (navigator.canShare({ files: [file] })) {
            await navigator.share({
              files: [file],
              title: 'Anime Image',
              text: 'Downloaded from AniGen'
            });
            return;
          }
        }
        
        // Fallback for mobile: open image in new tab for manual save
        const newWindow = window.open(imageData.url, '_blank');
        if (!newWindow) {
          throw new Error('Popup blocked');
        }
      } catch (error) {
        throw error;
      }
    }

    private fallbackDownload(imageData: ImageData): void {
      // Simple fallback method
      const link = document.createElement('a');
      link.href = imageData.url;
      link.download = `anime_image_${Date.now()}.jpg`;
      link.target = '_blank';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }

    private getImageExtension(url: string): string {
      try {
        const urlPath = new URL(url).pathname;
        const extension = urlPath.split('.').pop()?.toLowerCase();
        
        // Common image extensions
        const validExtensions = ['jpg', 'jpeg', 'png', 'gif', 'webp', 'svg'];
        if (extension && validExtensions.includes(extension)) {
          return `.${extension}`;
        }
      } catch (error) {
        console.warn('Could not parse URL for extension:', error);
      }
      
      // Default fallback
      return '.jpg';
    }

    private handleKeyPress(event: KeyboardEvent): void {
      // Ignore if user is typing in an input
      if (event.target instanceof HTMLInputElement || event.target instanceof HTMLTextAreaElement) {
        return;
      }

      // Hide keyboard hint on first key press
      this.hideKeyboardHint();

      switch (event.key.toLowerCase()) {
        case 'a':
        case 'arrowleft':
          event.preventDefault();
          this.goToPreviousImage();
          break;
        case 'd':
        case 'arrowright':
          event.preventDefault();
          this.goToNextImageOrLoadNew();
          break;
        case 'w':
        case 'arrowup':
          event.preventDefault();
          if (!this.isFullscreen) {
            this.toggleFullscreen(true);
          }
          break;
        case 's':
        case 'arrowdown':
          event.preventDefault();
          this.toggleFullscreen(false);
          break;
        case 'f':
          event.preventDefault();
          this.downloadImage();
          break;
        case 'escape':
          event.preventDefault();
          this.toggleFullscreen(false);
          break;
      }
    }

    private handleTouchStart(event: TouchEvent): void {
      this.touchStartX = event.changedTouches[0].screenX;
    }

    private handleTouchEnd(event: TouchEvent): void {
      this.touchEndX = event.changedTouches[0].screenX;
      // Throttle swipe handling
      this.debounce('swipe', () => {
        this.handleSwipe();
      }, 50);
    }

    private handleMouseDown(event: MouseEvent): void {
      this.touchStartX = event.screenX;
    }

    private handleMouseUp(event: MouseEvent): void {
      this.touchEndX = event.screenX;
      // Throttle swipe handling
      this.debounce('swipe', () => {
        this.handleSwipe();
      }, 50);
    }

    private handleSwipe(): void {
      const swipeThreshold = 50;
      const swipeDistance = this.touchEndX - this.touchStartX;

      if (Math.abs(swipeDistance) > swipeThreshold) {
        if (swipeDistance > 0) {
          // Swipe right - go to previous image
          this.goToPreviousImage();
        } else {
          // Swipe left - go to next image or load new
          this.goToNextImageOrLoadNew();
        }
      }
    }

    private toggleFullscreen(enable: boolean): void {
      this.isFullscreen = enable;
      
      if (enable) {
        document.body.style.overflow = 'hidden';
        this.container.style.display = 'none';
        this.keyboardHint.style.display = 'none';
        
        // Create fullscreen main content
        const fullscreenContent = document.createElement('div');
        fullscreenContent.className = 'main-content fullscreen';
        fullscreenContent.id = 'fullscreenContent';
        
        // Clone and move image container to fullscreen content
        const clonedContainer = this.imageContainer.cloneNode(true) as HTMLElement;
        clonedContainer.classList.add('fullscreen');
        const clonedImage = clonedContainer.querySelector('.main-image') as HTMLImageElement;
        if (clonedImage) {
          clonedImage.classList.add('fullscreen');
        }
        
        fullscreenContent.appendChild(clonedContainer);
        document.body.appendChild(fullscreenContent);
        
        // Hide original image container
        this.imageContainer.style.display = 'none';
      } else {
        document.body.style.overflow = '';
        this.container.style.display = 'flex';
        this.keyboardHint.style.display = 'block';
        this.imageContainer.style.display = 'flex';
        
        // Remove fullscreen content
        const fullscreenContent = document.getElementById('fullscreenContent');
        if (fullscreenContent) {
          fullscreenContent.remove();
        }
      }
    }

    private showSwipeHint(): void {
      // Update hint text based on device type
      const hintText = this.isMobileDevice 
        ? "Swipe to navigate" 
        : "Use A/D or arrow keys to navigate";
      
      this.swipeHint.textContent = hintText;
      this.swipeHint.classList.add('show');
      
      setTimeout(() => {
        this.swipeHint.classList.remove('show');
      }, 3000);
    }

    private hideKeyboardHint(): void {
      if (this.keyboardHintVisible) {
        this.keyboardHintVisible = false;
        this.keyboardHint.style.opacity = '0';
        this.keyboardHint.style.pointerEvents = 'none';
        
        // Completely hide after transition (match CSS transition time)
        setTimeout(() => {
          this.keyboardHint.style.display = 'none';
        }, 600);
      }
    }

    private showAlert(message: string, backgroundColor: string = 'rgba(255, 0, 0, 0.9)'): void {
      // Create a temporary alert
      const alert = document.createElement('div');
      alert.textContent = message;
      alert.style.cssText = `
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: ${backgroundColor};
        color: white;
        padding: 1rem 2rem;
        border-radius: 10px;
        z-index: 20000;
        font-size: 0.9rem;
        max-width: 80%;
        text-align: center;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      `;
      
      document.body.appendChild(alert);
      
      setTimeout(() => {
        if (alert.parentNode) {
          alert.parentNode.removeChild(alert);
        }
      }, 3000);
    }
  }

  // Initialize the app when DOM is loaded
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => new AnimeImageViewer());
  } else {
    new AnimeImageViewer();
  }
</script>
